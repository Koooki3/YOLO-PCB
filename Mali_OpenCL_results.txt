一、CPP代码：
#define CL_TARGET_OPENCL_VERSION 300  // 定义目标OpenCL版本（3.0）
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <CL/cl.h>

#define MAX_PLATFORMS 10
#define MAX_DEVICES 10
#define DATA_SIZE 1024  // 测试数据大小

// 打印设备信息
void printDeviceInfo(cl_device_id device) {
    char device_name[256];
    char device_vendor[256];
    char device_version[256];
    char driver_version[256];
    char device_extensions[4096];

    clGetDeviceInfo(device, CL_DEVICE_NAME, sizeof(device_name), device_name, NULL);
    clGetDeviceInfo(device, CL_DEVICE_VENDOR, sizeof(device_vendor), device_vendor, NULL);
    clGetDeviceInfo(device, CL_DEVICE_VERSION, sizeof(device_version), device_version, NULL);
    clGetDeviceInfo(device, CL_DRIVER_VERSION, sizeof(driver_version), driver_version, NULL);

    cl_ulong global_mem_size;
    cl_ulong local_mem_size;
    cl_uint max_compute_units;
    size_t max_work_group_size;
    cl_uint max_work_item_dimensions;
    size_t max_work_item_sizes[3];

    clGetDeviceInfo(device, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(global_mem_size), &global_mem_size, NULL);
    clGetDeviceInfo(device, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(local_mem_size), &local_mem_size, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(max_compute_units), &max_compute_units, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(max_work_item_dimensions), &max_work_item_dimensions, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(max_work_item_sizes), max_work_item_sizes, NULL);
    clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, sizeof(device_extensions), device_extensions, NULL);

    printf("    Device Name: %s\n", device_name);
    printf("    Vendor: %s\n", device_vendor);
    printf("    Device Version: %s\n", device_version);
    printf("    Driver Version: %s\n", driver_version);
    printf("    Global Memory Size: %lu MB\n", global_mem_size / (1024 * 1024));
    printf("    Local Memory Size: %lu KB\n", local_mem_size / 1024);
    printf("    Max Compute Units: %u\n", max_compute_units);
    printf("    Max Work Group Size: %zu\n", max_work_group_size);
    printf("    Max Work Item Dimensions: %u\n", max_work_item_dimensions);
    printf("    Max Work Item Sizes: [%zu, %zu, %zu]\n",
           max_work_item_sizes[0], max_work_item_sizes[1], max_work_item_sizes[2]);

    // 检查重要扩展
    printf("    Important Extensions:\n");
    if (strstr(device_extensions, "cl_khr_fp64")) printf("      - Double precision support (cl_khr_fp64)\n");
    if (strstr(device_extensions, "cl_khr_fp16")) printf("      - Half precision support (cl_khr_fp16)\n");
    if (strstr(device_extensions, "cl_arm_integer_dot_product_int8")) printf("      - Integer dot product (cl_arm_integer_dot_product_int8)\n");
    if (strstr(device_extensions, "cl_arm_printf")) printf("      - Kernel printf support (cl_arm_printf)\n");
}

// 向量加法OpenCL内核
const char* vector_add_kernel =
"__kernel void vector_add(__global const float* a, __global const float* b, __global float* result) {\n"
"    int idx = get_global_id(0);\n"
"    result[idx] = a[idx] + b[idx];\n"
"}\n";

// 矩阵乘法OpenCL内核
const char* matrix_mul_kernel =
"__kernel void matrix_mul(__global const float* a, __global const float* b, __global float* c, \n"
"                         int width_a, int width_b) {\n"
"    int row = get_global_id(0);\n"
"    int col = get_global_id(1);\n"
"    \n"
"    float sum = 0.0f;\n"
"    for (int k = 0; k < width_a; k++) {\n"
"        sum += a[row * width_a + k] * b[k * width_b + col];\n"
"    }\n"
"    c[row * width_b + col] = sum;\n"
"}\n";

// 性能测试内核
const char* performance_kernel =
"__kernel void performance_test(__global float* data) {\n"
"    int idx = get_global_id(0);\n"
"    float x = (float)idx;\n"
"    \n"
"    // 一些数学运算来测试性能\n"
"    for (int i = 0; i < 100; i++) {\n"
"        x = sin(x) * cos(x) + sqrt(fabs(x));\n"
"    }\n"
"    \n"
"    data[idx] = x;\n"
"}\n";

int main() {
    cl_platform_id platforms[MAX_PLATFORMS];
    cl_device_id devices[MAX_DEVICES];
    cl_uint num_platforms, num_devices;
    cl_context context;
    cl_command_queue command_queue;
    cl_program program;
    cl_kernel kernel;
    cl_int ret;

    printf("=== Mali GPU OpenCL 完整测试 ===\n\n");

    // 1. 获取平台数量
    ret = clGetPlatformIDs(MAX_PLATFORMS, platforms, &num_platforms);
    if (ret != CL_SUCCESS || num_platforms == 0) {
        printf("错误: 没有找到OpenCL平台\n");
        return -1;
    }

    printf("找到 %u 个OpenCL平台:\n", num_platforms);

    // 2. 遍历打印平台信息
    for (cl_uint i = 0; i < num_platforms; i++) {
        char platform_name[128];
        char platform_vendor[128];
        char platform_version[128];

        clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, sizeof(platform_name), platform_name, NULL);
        clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, sizeof(platform_vendor), platform_vendor, NULL);
        clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, sizeof(platform_version), platform_version, NULL);

        printf("平台 %u:\n", i);
        printf("    名称: %s\n", platform_name);
        printf("    供应商: %s\n", platform_vendor);
        printf("    版本: %s\n", platform_version);

        // 3. 获取设备信息
        cl_uint device_count;
        ret = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, MAX_DEVICES, devices, &device_count);
        if (ret != CL_SUCCESS) {
            printf("    警告: 无法获取设备列表\n");
            continue;
        }

        printf("    找到 %u 个设备:\n", device_count);

        for (cl_uint j = 0; j < device_count; j++) {
            printf("    设备 %u:\n", j);
            printDeviceInfo(devices[j]);
        }
    }

    // 4. 使用第一个平台的第一个GPU设备
    ret = clGetDeviceIDs(platforms[0], CL_DEVICE_TYPE_GPU, MAX_DEVICES, devices, &num_devices);
    if (ret != CL_SUCCESS || num_devices == 0) {
        printf("错误: 没有找到GPU设备\n");
        return -1;
    }

    printf("\n=== 使用设备: ===\n");
    printDeviceInfo(devices[0]);

    // 5. 创建OpenCL上下文
    context = clCreateContext(NULL, 1, &devices[0], NULL, NULL, &ret);
    if (ret != CL_SUCCESS) {
        printf("错误: 无法创建OpenCL上下文\n");
        return -1;
    }

    // 6. 创建命令队列
    command_queue = clCreateCommandQueue(context, devices[0], CL_QUEUE_PROFILING_ENABLE, &ret);
    if (ret != CL_SUCCESS) {
        printf("错误: 无法创建命令队列\n");
        return -1;
    }

    printf("\n=== 测试1: 向量加法 ===\n");

    // 7. 创建向量加法程序
    program = clCreateProgramWithSource(context, 1, &vector_add_kernel, NULL, &ret);
    if (ret != CL_SUCCESS) {
        printf("错误: 无法创建程序\n");
        return -1;
    }

    // 8. 构建程序
    ret = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);
    if (ret != CL_SUCCESS) {
        printf("错误: 程序构建失败\n");
        // 获取构建日志
        size_t log_size;
        clGetProgramBuildInfo(program, devices[0], CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
        char *log = (char *)malloc(log_size);
        clGetProgramBuildInfo(program, devices[0], CL_PROGRAM_BUILD_LOG, log_size, log, NULL);
        printf("构建日志:\n%s\n", log);
        free(log);
        return -1;
    }

    // 9. 创建内核
    kernel = clCreateKernel(program, "vector_add", &ret);
    if (ret != CL_SUCCESS) {
        printf("错误: 无法创建内核\n");
        return -1;
    }

    // 10. 准备测试数据
    size_t data_bytes = DATA_SIZE * sizeof(float);
    float *a = (float*)malloc(data_bytes);
    float *b = (float*)malloc(data_bytes);
    float *results = (float*)malloc(data_bytes);
    float *cpu_results = (float*)malloc(data_bytes);

    srand(time(NULL));
    for (size_t i = 0; i < DATA_SIZE; i++) {
        a[i] = (float)rand() / RAND_MAX * 100.0f;
        b[i] = (float)rand() / RAND_MAX * 100.0f;
        cpu_results[i] = a[i] + b[i];  // CPU计算结果用于验证
    }

    // 11. 创建OpenCL缓冲区
    cl_mem a_buffer = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     data_bytes, a, &ret);
    cl_mem b_buffer = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     data_bytes, b, &ret);
    cl_mem results_buffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY,
                                          data_bytes, NULL, &ret);

    // 12. 设置内核参数
    ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), &a_buffer);
    ret |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &b_buffer);
    ret |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &results_buffer);

    if (ret != CL_SUCCESS) {
        printf("错误: 无法设置内核参数\n");
        return -1;
    }

    // 13. 执行内核（带性能测量）
    cl_event event;
    size_t global_work_size = DATA_SIZE;
    size_t local_work_size = 64;  // 典型的工作组大小

    ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL,
                                 &global_work_size, &local_work_size,
                                 0, NULL, &event);
    if (ret != CL_SUCCESS) {
        printf("错误: 无法执行内核\n");
        return -1;
    }

    clWaitForEvents(1, &event);

    // 14. 获取性能数据
    cl_ulong start_time, end_time;
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_START,
                           sizeof(cl_ulong), &start_time, NULL);
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_END,
                           sizeof(cl_ulong), &end_time, NULL);

    double gpu_time = (end_time - start_time) / 1e6;  // 转换为毫秒

    // 15. 读取结果
    ret = clEnqueueReadBuffer(command_queue, results_buffer, CL_TRUE, 0,
                             data_bytes, results, 0, NULL, NULL);

    // 16. 验证结果
    int errors = 0;
    for (size_t i = 0; i < DATA_SIZE; i++) {
        if (fabs(results[i] - cpu_results[i]) > 0.001f) {
            errors++;
            if (errors < 10) {
                printf("    错误: results[%zu] = %f, 期望 = %f\n",
                       i, results[i], cpu_results[i]);
            }
        }
    }

    if (errors == 0) {
        printf("    测试通过: 向量加法正确\n");
        printf("    执行时间: %.3f ms\n", gpu_time);
        printf("    吞吐量: %.2f MFLOPs\n",
               (DATA_SIZE * 1.0) / (gpu_time / 1000.0) / 1e6);
    } else {
        printf("    测试失败: 发现 %d 个错误\n", errors);
    }

    // 清理测试1的资源
    clReleaseMemObject(a_buffer);
    clReleaseMemObject(b_buffer);
    clReleaseMemObject(results_buffer);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseEvent(event);

    printf("\n=== 测试2: 矩阵乘法 ===\n");

    // 17. 测试矩阵乘法
    const int MATRIX_SIZE = 32;  // 小矩阵，适合测试
    int matrix_bytes = MATRIX_SIZE * MATRIX_SIZE * sizeof(float);

    // 创建矩阵乘法程序
    program = clCreateProgramWithSource(context, 1, &matrix_mul_kernel, NULL, &ret);
    ret = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);
    kernel = clCreateKernel(program, "matrix_mul", &ret);

    // 准备矩阵数据
    float *matrix_a = (float*)malloc(matrix_bytes);
    float *matrix_b = (float*)malloc(matrix_bytes);
    float *matrix_c = (float*)malloc(matrix_bytes);
    float *matrix_c_cpu = (float*)malloc(matrix_bytes);

    for (int i = 0; i < MATRIX_SIZE * MATRIX_SIZE; i++) {
        matrix_a[i] = (float)rand() / RAND_MAX * 10.0f;
        matrix_b[i] = (float)rand() / RAND_MAX * 10.0f;
        matrix_c_cpu[i] = 0.0f;
    }

    // CPU矩阵乘法
    clock_t cpu_start = clock();
    for (int i = 0; i < MATRIX_SIZE; i++) {
        for (int j = 0; j < MATRIX_SIZE; j++) {
            float sum = 0.0f;
            for (int k = 0; k < MATRIX_SIZE; k++) {
                sum += matrix_a[i * MATRIX_SIZE + k] * matrix_b[k * MATRIX_SIZE + j];
            }
            matrix_c_cpu[i * MATRIX_SIZE + j] = sum;
        }
    }
    clock_t cpu_end = clock();
    double cpu_time = (double)(cpu_end - cpu_start) / CLOCKS_PER_SEC * 1000.0;

    // GPU矩阵乘法
    cl_mem buffer_a = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    matrix_bytes, matrix_a, &ret);
    cl_mem buffer_b = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    matrix_bytes, matrix_b, &ret);
    cl_mem buffer_c = clCreateBuffer(context, CL_MEM_WRITE_ONLY,
                                    matrix_bytes, NULL, &ret);

    int width_a = MATRIX_SIZE;
    int width_b = MATRIX_SIZE;
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &buffer_a);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &buffer_b);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &buffer_c);
    clSetKernelArg(kernel, 3, sizeof(int), &width_a);
    clSetKernelArg(kernel, 4, sizeof(int), &width_b);

    size_t global_work_size2[2] = {MATRIX_SIZE, MATRIX_SIZE};
    size_t local_work_size2[2] = {8, 8};  // 适合Mali的局部工作组大小

    cl_event event2;
    ret = clEnqueueNDRangeKernel(command_queue, kernel, 2, NULL,
                                global_work_size2, local_work_size2,
                                0, NULL, &event2);

    clWaitForEvents(1, &event2);
    clEnqueueReadBuffer(command_queue, buffer_c, CL_TRUE, 0,
                       matrix_bytes, matrix_c, 0, NULL, NULL);

    // 获取GPU时间
    clGetEventProfilingInfo(event2, CL_PROFILING_COMMAND_START,
                           sizeof(cl_ulong), &start_time, NULL);
    clGetEventProfilingInfo(event2, CL_PROFILING_COMMAND_END,
                           sizeof(cl_ulong), &end_time, NULL);
    double gpu_time2 = (end_time - start_time) / 1e6;

    // 验证结果
    errors = 0;
    for (int i = 0; i < MATRIX_SIZE * MATRIX_SIZE; i++) {
        if (fabs(matrix_c[i] - matrix_c_cpu[i]) > 0.01f) {
            errors++;
        }
    }

    if (errors == 0) {
        printf("    测试通过: 矩阵乘法正确\n");
        printf("    CPU时间: %.3f ms\n", cpu_time);
        printf("    GPU时间: %.3f ms\n", gpu_time2);
        printf("    加速比: %.2fx\n", cpu_time / gpu_time2);
    } else {
        printf("    测试失败: 发现 %d 个错误\n", errors);
    }

    // 清理测试2的资源
    clReleaseMemObject(buffer_a);
    clReleaseMemObject(buffer_b);
    clReleaseMemObject(buffer_c);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseEvent(event2);

    // 18. 测试性能（数学运算密集型）
    printf("\n=== 测试3: 数学运算性能 ===\n");

    program = clCreateProgramWithSource(context, 1, &performance_kernel, NULL, &ret);
    ret = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);
    kernel = clCreateKernel(program, "performance_test", &ret);

    float *perf_data = (float*)malloc(data_bytes);
    cl_mem perf_buffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, data_bytes, NULL, &ret);
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &perf_buffer);

    cl_event event3;
    ret = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL,
                                &global_work_size, &local_work_size,
                                0, NULL, &event3);
    clWaitForEvents(1, &event3);
    clEnqueueReadBuffer(command_queue, perf_buffer, CL_TRUE, 0,
                       data_bytes, perf_data, 0, NULL, NULL);

    clGetEventProfilingInfo(event3, CL_PROFILING_COMMAND_START,
                           sizeof(cl_ulong), &start_time, NULL);
    clGetEventProfilingInfo(event3, CL_PROFILING_COMMAND_END,
                           sizeof(cl_ulong), &end_time, NULL);
    double gpu_time3 = (end_time - start_time) / 1e6;

    printf("    数学运算时间: %.3f ms\n", gpu_time3);
    printf("    性能: %.2f GFLOPS\n",
           (DATA_SIZE * 100.0 * 5.0) / (gpu_time3 / 1000.0) / 1e9);

    // 19. 内存带宽测试
    printf("\n=== 测试4: 内存带宽 ===\n");

    // 简单内存拷贝测试
    cl_mem src_buffer = clCreateBuffer(context, CL_MEM_READ_ONLY, data_bytes, NULL, &ret);
    cl_mem dst_buffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, data_bytes, NULL, &ret);

    cl_event copy_event;
    ret = clEnqueueCopyBuffer(command_queue, src_buffer, dst_buffer, 0, 0,
                             data_bytes, 0, NULL, &copy_event);
    clWaitForEvents(1, &copy_event);

    clGetEventProfilingInfo(copy_event, CL_PROFILING_COMMAND_START,
                           sizeof(cl_ulong), &start_time, NULL);
    clGetEventProfilingInfo(copy_event, CL_PROFILING_COMMAND_END,
                           sizeof(cl_ulong), &end_time, NULL);
    double copy_time = (end_time - start_time) / 1e6;
    double bandwidth = (data_bytes * 2.0) / (copy_time / 1000.0) / (1024*1024*1024);

    printf("    内存拷贝时间: %.3f ms\n", copy_time);
    printf("    估计带宽: %.2f GB/s\n", bandwidth);

    // 20. 资源清理
    clReleaseMemObject(src_buffer);
    clReleaseMemObject(dst_buffer);
    clReleaseMemObject(perf_buffer);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseEvent(event3);
    clReleaseEvent(copy_event);
    clReleaseCommandQueue(command_queue);
    clReleaseContext(context);

    // 释放主机内存
    free(a);
    free(b);
    free(results);
    free(cpu_results);
    free(matrix_a);
    free(matrix_b);
    free(matrix_c);
    free(matrix_c_cpu);
    free(perf_data);

    printf("\n=== 测试完成 ===\n");
    return 0;
}

二、运行结果：
=== Mali GPU OpenCL 完整测试 ===

arm_release_ver: g13p0-01eac0, rk_so_ver: 10
找到 1 个OpenCL平台:
平台 0:
    名称: ARM Platform
    供应商: ARM
    版本: OpenCL 3.0 v1.g13p0-01eac0.68603db295fbf2c59ac6b927fdfb1c32
    找到 1 个设备:
    设备 0:
    Device Name: Mali-G610 r0p0
    Vendor: ARM
    Device Version: OpenCL 3.0 v1.g13p0-01eac0.68603db295fbf2c59ac6b927fdfb1c32
    Driver Version: 3.0
    Global Memory Size: 7927 MB
    Local Memory Size: 32 KB
    Max Compute Units: 4
    Max Work Group Size: 1024
    Max Work Item Dimensions: 3
    Max Work Item Sizes: [1024, 1024, 1024]
    Important Extensions:
      - Half precision support (cl_khr_fp16)
      - Integer dot product (cl_arm_integer_dot_product_int8)
      - Kernel printf support (cl_arm_printf)

=== 使用设备: ===
    Device Name: Mali-G610 r0p0
    Vendor: ARM
    Device Version: OpenCL 3.0 v1.g13p0-01eac0.68603db295fbf2c59ac6b927fdfb1c32
    Driver Version: 3.0
    Global Memory Size: 7927 MB
    Local Memory Size: 32 KB
    Max Compute Units: 4
    Max Work Group Size: 1024
    Max Work Item Dimensions: 3
    Max Work Item Sizes: [1024, 1024, 1024]
    Important Extensions:
      - Half precision support (cl_khr_fp16)
      - Integer dot product (cl_arm_integer_dot_product_int8)
      - Kernel printf support (cl_arm_printf)

=== 测试1: 向量加法 ===
    测试通过: 向量加法正确
    执行时间: 0.013 ms
    吞吐量: 76.27 MFLOPs

=== 测试2: 矩阵乘法 ===
    测试通过: 矩阵乘法正确
    CPU时间: 0.134 ms
    GPU时间: 0.083 ms
    加速比: 1.61x

=== 测试3: 数学运算性能 ===
    数学运算时间: 0.229 ms
    性能: 2.23 GFLOPS

=== 测试4: 内存带宽 ===
    内存拷贝时间: 0.004 ms
    估计带宽: 1.87 GB/s

=== 测试完成 ===